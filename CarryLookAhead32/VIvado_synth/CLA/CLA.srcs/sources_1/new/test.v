//
// Generated by Bluespec Compiler, version 2024.01-13-ga8fe68a6 (build a8fe68a6)
//
// On Fri Jun  7 11:16:39 IST 2024
//
//
// Ports:
// Name                         I/O  size props
// RDY_start                      O     1 const
// return_sum                     O     8 reg
// RDY_return_sum                 O     1 const
// return_carry                   O     1 reg
// RDY_return_carry               O     1 const
// overflow                       O     1
// RDY_overflow                   O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// start_in1                      I     8 reg
// start_in2                      I     8 reg
// start_cin                      I     1 reg
// EN_start                       I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkCLA8(CLK,
	      RST_N,

	      start_in1,
	      start_in2,
	      start_cin,
	      EN_start,
	      RDY_start,

	      return_sum,
	      RDY_return_sum,

	      return_carry,
	      RDY_return_carry,

	      overflow,
	      RDY_overflow);
  input  CLK;
  input  RST_N;

  // action method start
  input  [7 : 0] start_in1;
  input  [7 : 0] start_in2;
  input  start_cin;
  input  EN_start;
  output RDY_start;

  // value method return_sum
  output [7 : 0] return_sum;
  output RDY_return_sum;

  // value method return_carry
  output return_carry;
  output RDY_return_carry;

  // value method overflow
  output overflow;
  output RDY_overflow;

  // signals for module outputs
  wire [7 : 0] return_sum;
  wire RDY_overflow,
       RDY_return_carry,
       RDY_return_sum,
       RDY_start,
       overflow,
       return_carry;

  // register available
  reg available;
  wire available_D_IN, available_EN;

  // register cin
  reg cin;
  wire cin_D_IN, cin_EN;

  // register in1
  reg [7 : 0] in1;
  wire [7 : 0] in1_D_IN;
  wire in1_EN;

  // register in2
  reg [7 : 0] in2;
  wire [7 : 0] in2_D_IN;
  wire in2_EN;

  // register result
  reg [8 : 0] result;
  wire [8 : 0] result_D_IN;
  wire result_EN;

  // rule scheduling signals
  wire CAN_FIRE_RL_call_compute,
       CAN_FIRE_start,
       WILL_FIRE_RL_call_compute,
       WILL_FIRE_start;

  // remaining internal signals
  wire [7 : 0] in1_AND_in2___d9, p__h243, sum_val__h247;
  wire x__h1211,
       x__h1213,
       x__h1428,
       x__h1430,
       x__h1645,
       x__h1647,
       x__h1862,
       x__h1864,
       x__h2079,
       x__h2081,
       x__h2500,
       x__h2502,
       x__h559,
       x__h777,
       x__h779,
       x__h994,
       x__h996,
       y__h2501;

  // action method start
  assign RDY_start = 1'd1 ;
  assign CAN_FIRE_start = 1'd1 ;
  assign WILL_FIRE_start = EN_start ;

  // value method return_sum
  assign return_sum = result[7:0] ;
  assign RDY_return_sum = 1'd1 ;

  // value method return_carry
  assign return_carry = result[8] ;
  assign RDY_return_carry = 1'd1 ;

  // value method overflow
  assign overflow = x__h2500 & y__h2501 ;
  assign RDY_overflow = available ;

  // rule RL_call_compute
  assign CAN_FIRE_RL_call_compute = !available ;
  assign WILL_FIRE_RL_call_compute = CAN_FIRE_RL_call_compute ;

  // register available
  assign available_D_IN = !EN_start ;
  assign available_EN = EN_start || WILL_FIRE_RL_call_compute ;

  // register cin
  assign cin_D_IN = start_cin ;
  assign cin_EN = EN_start ;

  // register in1
  assign in1_D_IN = start_in1 ;
  assign in1_EN = EN_start ;

  // register in2
  assign in2_D_IN = start_in2 ;
  assign in2_EN = EN_start ;

  // register result
  assign result_D_IN = { x__h2079 | in1_AND_in2___d9[7], sum_val__h247 } ;
  assign result_EN = CAN_FIRE_RL_call_compute ;

  // remaining internal signals
  assign in1_AND_in2___d9 = in1 & in2 ;
  assign p__h243 = in1 ^ in2 ;
  assign sum_val__h247 =
	     p__h243 ^
	     { x__h2081,
	       x__h1864,
	       x__h1647,
	       x__h1430,
	       x__h1213,
	       x__h996,
	       x__h779,
	       cin } ;
  assign x__h1211 = x__h1213 & p__h243[3] ;
  assign x__h1213 = x__h994 | in1_AND_in2___d9[2] ;
  assign x__h1428 = x__h1430 & p__h243[4] ;
  assign x__h1430 = x__h1211 | in1_AND_in2___d9[3] ;
  assign x__h1645 = x__h1647 & p__h243[5] ;
  assign x__h1647 = x__h1428 | in1_AND_in2___d9[4] ;
  assign x__h1862 = x__h1864 & p__h243[6] ;
  assign x__h1864 = x__h1645 | in1_AND_in2___d9[5] ;
  assign x__h2079 = x__h2081 & p__h243[7] ;
  assign x__h2081 = x__h1862 | in1_AND_in2___d9[6] ;
  assign x__h2500 = x__h2502 ^ in2[7] ;
  assign x__h2502 = ~in1[7] ;
  assign x__h559 = cin & p__h243[0] ;
  assign x__h777 = x__h779 & p__h243[1] ;
  assign x__h779 = x__h559 | in1_AND_in2___d9[0] ;
  assign x__h994 = x__h996 & p__h243[2] ;
  assign x__h996 = x__h777 | in1_AND_in2___d9[1] ;
  assign y__h2501 = in2[7] ^ result[7] ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        available <= `BSV_ASSIGNMENT_DELAY 1'd1;
	cin <= `BSV_ASSIGNMENT_DELAY 1'd0;
	in1 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	in2 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	result <= `BSV_ASSIGNMENT_DELAY 9'd0;
      end
    else
      begin
        if (available_EN) available <= `BSV_ASSIGNMENT_DELAY available_D_IN;
	if (cin_EN) cin <= `BSV_ASSIGNMENT_DELAY cin_D_IN;
	if (in1_EN) in1 <= `BSV_ASSIGNMENT_DELAY in1_D_IN;
	if (in2_EN) in2 <= `BSV_ASSIGNMENT_DELAY in2_D_IN;
	if (result_EN) result <= `BSV_ASSIGNMENT_DELAY result_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    available = 1'h0;
    cin = 1'h0;
    in1 = 8'hAA;
    in2 = 8'hAA;
    result = 9'h0AA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkCLA8
