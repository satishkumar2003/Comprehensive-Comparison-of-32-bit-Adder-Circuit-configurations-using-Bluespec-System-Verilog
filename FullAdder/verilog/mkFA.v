//
// Generated by Bluespec Compiler, version 2024.01-13-ga8fe68a6 (build a8fe68a6)
//
// On Wed Jun  5 11:26:57 IST 2024
//
//
// Ports:
// Name                         I/O  size props
// RDY_start                      O     1 const
// return_sum                     O     1 reg
// RDY_return_sum                 O     1 reg
// return_cout                    O     1 reg
// RDY_return_cout                O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// start_in1                      I     1 reg
// start_in2                      I     1 reg
// start_cin                      I     1 reg
// EN_start                       I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkFA(CLK,
	    RST_N,

	    start_in1,
	    start_in2,
	    start_cin,
	    EN_start,
	    RDY_start,

	    return_sum,
	    RDY_return_sum,

	    return_cout,
	    RDY_return_cout);
  input  CLK;
  input  RST_N;

  // action method start
  input  start_in1;
  input  start_in2;
  input  start_cin;
  input  EN_start;
  output RDY_start;

  // value method return_sum
  output return_sum;
  output RDY_return_sum;

  // value method return_cout
  output return_cout;
  output RDY_return_cout;

  // signals for module outputs
  wire RDY_return_cout, RDY_return_sum, RDY_start, return_cout, return_sum;

  // register available
  reg available;
  wire available_D_IN, available_EN;

  // register cin
  reg cin;
  wire cin_D_IN, cin_EN;

  // register in1
  reg in1;
  wire in1_D_IN, in1_EN;

  // register in2
  reg in2;
  wire in2_D_IN, in2_EN;

  // register result
  reg [1 : 0] result;
  wire [1 : 0] result_D_IN;
  wire result_EN;

  // rule scheduling signals
  wire CAN_FIRE_RL_compute,
       CAN_FIRE_start,
       WILL_FIRE_RL_compute,
       WILL_FIRE_start;

  // remaining internal signals
  wire cout__h242, sum__h241, temp1__h240, x__h254, y__h255;

  // action method start
  assign RDY_start = 1'd1 ;
  assign CAN_FIRE_start = 1'd1 ;
  assign WILL_FIRE_start = EN_start ;

  // value method return_sum
  assign return_sum = result[0] ;
  assign RDY_return_sum = available ;

  // value method return_cout
  assign return_cout = result[1] ;
  assign RDY_return_cout = available ;

  // rule RL_compute
  assign CAN_FIRE_RL_compute = !available ;
  assign WILL_FIRE_RL_compute = CAN_FIRE_RL_compute ;

  // register available
  assign available_D_IN = !EN_start ;
  assign available_EN = EN_start || WILL_FIRE_RL_compute ;

  // register cin
  assign cin_D_IN = start_cin ;
  assign cin_EN = EN_start ;

  // register in1
  assign in1_D_IN = start_in1 ;
  assign in1_EN = EN_start ;

  // register in2
  assign in2_D_IN = start_in2 ;
  assign in2_EN = EN_start ;

  // register result
  assign result_D_IN = { cout__h242, sum__h241 } ;
  assign result_EN = CAN_FIRE_RL_compute ;

  // remaining internal signals
  assign cout__h242 = x__h254 | y__h255 ;
  assign sum__h241 = temp1__h240 ^ cin ;
  assign temp1__h240 = in1 ^ in2 ;
  assign x__h254 = in1 & in2 ;
  assign y__h255 = cin & temp1__h240 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        available <= `BSV_ASSIGNMENT_DELAY 1'd1;
	cin <= `BSV_ASSIGNMENT_DELAY 1'd0;
	in1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	in2 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	result <= `BSV_ASSIGNMENT_DELAY 2'd0;
      end
    else
      begin
        if (available_EN) available <= `BSV_ASSIGNMENT_DELAY available_D_IN;
	if (cin_EN) cin <= `BSV_ASSIGNMENT_DELAY cin_D_IN;
	if (in1_EN) in1 <= `BSV_ASSIGNMENT_DELAY in1_D_IN;
	if (in2_EN) in2 <= `BSV_ASSIGNMENT_DELAY in2_D_IN;
	if (result_EN) result <= `BSV_ASSIGNMENT_DELAY result_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    available = 1'h0;
    cin = 1'h0;
    in1 = 1'h0;
    in2 = 1'h0;
    result = 2'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkFA

