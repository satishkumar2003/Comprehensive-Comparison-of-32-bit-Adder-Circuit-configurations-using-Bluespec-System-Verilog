//
// Generated by Bluespec Compiler, version 2024.01-13-ga8fe68a6 (build a8fe68a6)
//
// On Fri Jun  7 11:46:27 IST 2024
//
//
// Ports:
// Name                         I/O  size props
// RDY_start                      O     1 const
// return_sum                     O     8 reg
// RDY_return_sum                 O     1 const
// return_carry                   O     1 reg
// RDY_return_carry               O     1 const
// overflow                       O     1
// RDY_overflow                   O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// start_in1                      I     8 reg
// start_in2                      I     8 reg
// start_cin                      I     1 reg
// EN_start                       I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkCSK8(CLK,
	      RST_N,

	      start_in1,
	      start_in2,
	      start_cin,
	      EN_start,
	      RDY_start,

	      return_sum,
	      RDY_return_sum,

	      return_carry,
	      RDY_return_carry,

	      overflow,
	      RDY_overflow);
  input  CLK;
  input  RST_N;

  // action method start
  input  [7 : 0] start_in1;
  input  [7 : 0] start_in2;
  input  start_cin;
  input  EN_start;
  output RDY_start;

  // value method return_sum
  output [7 : 0] return_sum;
  output RDY_return_sum;

  // value method return_carry
  output return_carry;
  output RDY_return_carry;

  // value method overflow
  output overflow;
  output RDY_overflow;

  // signals for module outputs
  wire [7 : 0] return_sum;
  wire RDY_overflow,
       RDY_return_carry,
       RDY_return_sum,
       RDY_start,
       overflow,
       return_carry;

  // register available
  reg available;
  wire available_D_IN, available_EN;

  // register cin
  reg cin;
  wire cin_D_IN, cin_EN;

  // register in1
  reg [7 : 0] in1;
  wire [7 : 0] in1_D_IN;
  wire in1_EN;

  // register in2
  reg [7 : 0] in2;
  wire [7 : 0] in2_D_IN;
  wire in2_EN;

  // register result
  reg [8 : 0] result;
  wire [8 : 0] result_D_IN;
  wire result_EN;

  // rule scheduling signals
  wire CAN_FIRE_RL_call_compute,
       CAN_FIRE_start,
       WILL_FIRE_RL_call_compute,
       WILL_FIRE_start;

  // remaining internal signals
  wire [3 : 0] in1_BITS_3_TO_0_AND_in2_BITS_3_TO_0___d11,
	       in1_BITS_7_TO_4_0_AND_in2_BITS_7_TO_4_1___d35,
	       p__h295,
	       p__h490,
	       sum__h299,
	       sum__h494,
	       x__h1582,
	       x__h2554;
  wire cin_4__h244,
       cout__h246,
       x__h1139,
       x__h1141,
       x__h1356,
       x__h1358,
       x__h1580,
       x__h1638,
       x__h1894,
       x__h1896,
       x__h2111,
       x__h2113,
       x__h2328,
       x__h2330,
       x__h2552,
       x__h258,
       x__h2835,
       x__h2837,
       x__h467,
       x__h664,
       x__h922,
       x__h924,
       y__h259,
       y__h2836,
       y__h468;

  // action method start
  assign RDY_start = 1'd1 ;
  assign CAN_FIRE_start = 1'd1 ;
  assign WILL_FIRE_start = EN_start ;

  // value method return_sum
  assign return_sum = result[7:0] ;
  assign RDY_return_sum = 1'd1 ;

  // value method return_carry
  assign return_carry = result[8] ;
  assign RDY_return_carry = 1'd1 ;

  // value method overflow
  assign overflow = x__h2835 & y__h2836 ;
  assign RDY_overflow = available ;

  // rule RL_call_compute
  assign CAN_FIRE_RL_call_compute = !available ;
  assign WILL_FIRE_RL_call_compute = CAN_FIRE_RL_call_compute ;

  // register available
  assign available_D_IN = !EN_start ;
  assign available_EN = EN_start || WILL_FIRE_RL_call_compute ;

  // register cin
  assign cin_D_IN = start_cin ;
  assign cin_EN = EN_start ;

  // register in1
  assign in1_D_IN = start_in1 ;
  assign in1_EN = EN_start ;

  // register in2
  assign in2_D_IN = start_in2 ;
  assign in2_EN = EN_start ;

  // register result
  assign result_D_IN = { cout__h246, sum__h299, sum__h494 } ;
  assign result_EN = CAN_FIRE_RL_call_compute ;

  // remaining internal signals
  assign cin_4__h244 = x__h467 | y__h468 ;
  assign cout__h246 = x__h258 | y__h259 ;
  assign in1_BITS_3_TO_0_AND_in2_BITS_3_TO_0___d11 = in1[3:0] & in2[3:0] ;
  assign in1_BITS_7_TO_4_0_AND_in2_BITS_7_TO_4_1___d35 = in1[7:4] & in2[7:4] ;
  assign p__h295 = in1[7:4] ^ in2[7:4] ;
  assign p__h490 = in1[3:0] ^ in2[3:0] ;
  assign sum__h299 = p__h295 ^ { x__h2330, x__h2113, x__h1896, cin_4__h244 } ;
  assign sum__h494 = p__h490 ^ { x__h1358, x__h1141, x__h924, cin } ;
  assign x__h1139 = x__h1141 & p__h490[2] ;
  assign x__h1141 = x__h922 | in1_BITS_3_TO_0_AND_in2_BITS_3_TO_0___d11[1] ;
  assign x__h1356 = x__h1358 & p__h490[3] ;
  assign x__h1358 = x__h1139 | in1_BITS_3_TO_0_AND_in2_BITS_3_TO_0___d11[2] ;
  assign x__h1580 = x__h1582 == 4'd15 ;
  assign x__h1582 = in1[3:0] | in2[3:0] ;
  assign x__h1638 = cin_4__h244 & p__h295[0] ;
  assign x__h1894 = x__h1896 & p__h295[1] ;
  assign x__h1896 =
	     x__h1638 | in1_BITS_7_TO_4_0_AND_in2_BITS_7_TO_4_1___d35[0] ;
  assign x__h2111 = x__h2113 & p__h295[2] ;
  assign x__h2113 =
	     x__h1894 | in1_BITS_7_TO_4_0_AND_in2_BITS_7_TO_4_1___d35[1] ;
  assign x__h2328 = x__h2330 & p__h295[3] ;
  assign x__h2330 =
	     x__h2111 | in1_BITS_7_TO_4_0_AND_in2_BITS_7_TO_4_1___d35[2] ;
  assign x__h2552 = x__h2554 == 4'd15 ;
  assign x__h2554 = in1[7:4] | in2[7:4] ;
  assign x__h258 =
	     x__h2328 | in1_BITS_7_TO_4_0_AND_in2_BITS_7_TO_4_1___d35[3] ;
  assign x__h2835 = x__h2837 ^ in2[7] ;
  assign x__h2837 = ~in1[7] ;
  assign x__h467 = x__h1356 | in1_BITS_3_TO_0_AND_in2_BITS_3_TO_0___d11[3] ;
  assign x__h664 = cin & p__h490[0] ;
  assign x__h922 = x__h924 & p__h490[1] ;
  assign x__h924 = x__h664 | in1_BITS_3_TO_0_AND_in2_BITS_3_TO_0___d11[0] ;
  assign y__h259 = x__h2552 & cin_4__h244 ;
  assign y__h2836 = in2[7] ^ result[7] ;
  assign y__h468 = x__h1580 & cin ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        available <= `BSV_ASSIGNMENT_DELAY 1'd1;
	cin <= `BSV_ASSIGNMENT_DELAY 1'd0;
	in1 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	in2 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	result <= `BSV_ASSIGNMENT_DELAY 9'd0;
      end
    else
      begin
        if (available_EN) available <= `BSV_ASSIGNMENT_DELAY available_D_IN;
	if (cin_EN) cin <= `BSV_ASSIGNMENT_DELAY cin_D_IN;
	if (in1_EN) in1 <= `BSV_ASSIGNMENT_DELAY in1_D_IN;
	if (in2_EN) in2 <= `BSV_ASSIGNMENT_DELAY in2_D_IN;
	if (result_EN) result <= `BSV_ASSIGNMENT_DELAY result_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    available = 1'h0;
    cin = 1'h0;
    in1 = 8'hAA;
    in2 = 8'hAA;
    result = 9'h0AA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkCSK8
