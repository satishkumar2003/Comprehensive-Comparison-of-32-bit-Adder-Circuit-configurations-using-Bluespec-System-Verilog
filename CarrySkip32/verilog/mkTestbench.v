//
// Generated by Bluespec Compiler, version 2024.01-13-ga8fe68a6 (build a8fe68a6)
//
// On Tue Jun 11 10:59:04 IST 2024
//
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkTestbench(CLK,
		   RST_N);
  input  CLK;
  input  RST_N;

  // register a
  reg [31 : 0] a;
  wire [31 : 0] a_D_IN;
  wire a_EN;

  // register adder_1_available
  reg adder_1_available;
  wire adder_1_available_D_IN, adder_1_available_EN;

  // register adder_1_cin
  reg adder_1_cin;
  wire adder_1_cin_D_IN, adder_1_cin_EN;

  // register adder_1_in1
  reg [31 : 0] adder_1_in1;
  wire [31 : 0] adder_1_in1_D_IN;
  wire adder_1_in1_EN;

  // register adder_1_in2
  reg [31 : 0] adder_1_in2;
  wire [31 : 0] adder_1_in2_D_IN;
  wire adder_1_in2_EN;

  // register adder_1_result
  reg [32 : 0] adder_1_result;
  wire [32 : 0] adder_1_result_D_IN;
  wire adder_1_result_EN;

  // register b
  reg [31 : 0] b;
  wire [31 : 0] b_D_IN;
  wire b_EN;

  // register cin
  reg cin;
  wire cin_D_IN, cin_EN;

  // register count
  reg [7 : 0] count;
  wire [7 : 0] count_D_IN;
  wire count_EN;

  // register cout
  reg cout;
  wire cout_D_IN, cout_EN;

  // register overflow_flag
  reg overflow_flag;
  wire overflow_flag_D_IN, overflow_flag_EN;

  // register rng_a_r
  reg [31 : 0] rng_a_r;
  wire [31 : 0] rng_a_r_D_IN;
  wire rng_a_r_EN;

  // register rng_b_r
  reg [31 : 0] rng_b_r;
  wire [31 : 0] rng_b_r_D_IN;
  wire rng_b_r_EN;

  // register rng_cin_r
  reg [7 : 0] rng_cin_r;
  wire [7 : 0] rng_cin_r_D_IN;
  wire rng_cin_r_EN;

  // register state
  reg [1 : 0] state;
  reg [1 : 0] state_D_IN;
  wire state_EN;

  // register sum
  reg [31 : 0] sum;
  wire [31 : 0] sum_D_IN;
  wire sum_EN;

  // rule scheduling signals
  wire CAN_FIRE_RL_adder_1_call_compute,
       CAN_FIRE_RL_display_results,
       CAN_FIRE_RL_generate_random_inputs,
       CAN_FIRE_RL_get_results,
       CAN_FIRE_RL_initialize,
       WILL_FIRE_RL_adder_1_call_compute,
       WILL_FIRE_RL_display_results,
       WILL_FIRE_RL_generate_random_inputs,
       WILL_FIRE_RL_get_results,
       WILL_FIRE_RL_initialize;

  // inputs to muxes for submodule ports
  wire [31 : 0] MUX_rng_a_r_write_1__VAL_1, MUX_rng_b_r_write_1__VAL_1;
  wire [7 : 0] MUX_rng_cin_r_write_1__VAL_1;
  wire MUX_state_write_1__SEL_1;

  // remaining internal signals
  wire [32 : 0] calculated_sum__h14822,
		expected_sum__h14821,
		x__h14999,
		x__h15001,
		y__h14840,
		y__h15002;
  wire [8 : 0] spliced_bits__h474;
  wire [7 : 0] adder_1_in1_BITS_15_TO_8_2_AND_adder_1_in2_BIT_ETC___d47,
	       adder_1_in1_BITS_15_TO_8_2_XOR_adder_1_in2_BIT_ETC___d44,
	       adder_1_in1_BITS_23_TO_16_8_AND_adder_1_in2_BI_ETC___d83,
	       adder_1_in1_BITS_23_TO_16_8_XOR_adder_1_in2_BI_ETC___d80,
	       adder_1_in1_BITS_31_TO_24_14_AND_adder_1_in2_B_ETC___d119,
	       adder_1_in1_BITS_7_TO_0_AND_adder_1_in2_BITS_7_ETC___d11,
	       adder_1_in1_BITS_7_TO_0_XOR_adder_1_in2_BITS_7_ETC___d8,
	       p__h8574,
	       sum_val__h2134,
	       sum_val__h4712,
	       sum_val__h842,
	       sum_val__h8578;
  wire _0_CONCAT_a_38_39_PLUS_0_CONCAT_b_40_41_42_PLUS_ETC___d249,
       adder_1_cin_AND_adder_1_in1_BITS_7_TO_0_XOR_ad_ETC___d113,
       adder_1_cin_AND_adder_1_in1_BITS_7_TO_0_XOR_ad_ETC___d77,
       cin__h2129,
       count_22_ULT_30___d237,
       x__h12658,
       x__h12809,
       x__h12811,
       x__h12917,
       x__h12919,
       x__h13025,
       x__h13027,
       x__h13133,
       x__h13135,
       x__h13241,
       x__h13243,
       x__h13349,
       x__h13351,
       x__h13457,
       x__h13459,
       x__h14654,
       x__h14656,
       x__h3636,
       x__h3787,
       x__h3789,
       x__h3895,
       x__h3897,
       x__h4003,
       x__h4005,
       x__h4111,
       x__h4113,
       x__h4219,
       x__h4221,
       x__h4327,
       x__h4329,
       x__h4435,
       x__h4437,
       x__h7503,
       x__h7654,
       x__h7656,
       x__h7762,
       x__h7764,
       x__h7870,
       x__h7872,
       x__h7978,
       x__h7980,
       x__h8086,
       x__h8088,
       x__h8194,
       x__h8196,
       x__h8302,
       x__h8304,
       x__h9078,
       x__h9229,
       x__h9231,
       x__h9337,
       x__h9339,
       x__h9445,
       x__h9447,
       x__h9553,
       x__h9555,
       x__h9661,
       x__h9663,
       x__h9769,
       x__h9771,
       x__h9877,
       x__h9879,
       y__h14655;

  // rule RL_initialize
  assign CAN_FIRE_RL_initialize = state == 2'd0 ;
  assign WILL_FIRE_RL_initialize = CAN_FIRE_RL_initialize ;

  // rule RL_get_results
  assign CAN_FIRE_RL_get_results = adder_1_available && state == 2'd2 ;
  assign WILL_FIRE_RL_get_results = CAN_FIRE_RL_get_results ;

  // rule RL_display_results
  assign CAN_FIRE_RL_display_results = state == 2'd3 ;
  assign WILL_FIRE_RL_display_results = CAN_FIRE_RL_display_results ;

  // rule RL_adder_1_call_compute
  assign CAN_FIRE_RL_adder_1_call_compute = !adder_1_available ;
  assign WILL_FIRE_RL_adder_1_call_compute =
	     CAN_FIRE_RL_adder_1_call_compute ;

  // rule RL_generate_random_inputs
  assign CAN_FIRE_RL_generate_random_inputs = state == 2'd1 ;
  assign WILL_FIRE_RL_generate_random_inputs =
	     CAN_FIRE_RL_generate_random_inputs ;

  // inputs to muxes for submodule ports
  assign MUX_state_write_1__SEL_1 =
	     WILL_FIRE_RL_display_results && count_22_ULT_30___d237 ;
  assign MUX_rng_a_r_write_1__VAL_1 =
	     rng_a_r[0] ?
	       { 1'd1,
		 rng_a_r[31:8],
		 ~rng_a_r[7],
		 rng_a_r[6],
		 ~rng_a_r[5],
		 rng_a_r[4],
		 ~rng_a_r[3:1] } :
	       { 1'd0, rng_a_r[31:1] } ;
  assign MUX_rng_b_r_write_1__VAL_1 =
	     rng_b_r[0] ?
	       { 1'd1,
		 rng_b_r[31:8],
		 ~rng_b_r[7],
		 rng_b_r[6],
		 ~rng_b_r[5],
		 rng_b_r[4],
		 ~rng_b_r[3:1] } :
	       { 1'd0, rng_b_r[31:1] } ;
  assign MUX_rng_cin_r_write_1__VAL_1 =
	     rng_cin_r[0] ?
	       { 1'd1, rng_cin_r[7:5], ~rng_cin_r[4:2], rng_cin_r[1] } :
	       { 1'd0, rng_cin_r[7:1] } ;

  // register a
  assign a_D_IN = rng_a_r ;
  assign a_EN = CAN_FIRE_RL_generate_random_inputs ;

  // register adder_1_available
  assign adder_1_available_D_IN = !WILL_FIRE_RL_generate_random_inputs ;
  assign adder_1_available_EN =
	     WILL_FIRE_RL_generate_random_inputs ||
	     WILL_FIRE_RL_adder_1_call_compute ;

  // register adder_1_cin
  assign adder_1_cin_D_IN = rng_cin_r[3] ;
  assign adder_1_cin_EN = CAN_FIRE_RL_generate_random_inputs ;

  // register adder_1_in1
  assign adder_1_in1_D_IN = rng_a_r ;
  assign adder_1_in1_EN = CAN_FIRE_RL_generate_random_inputs ;

  // register adder_1_in2
  assign adder_1_in2_D_IN = rng_b_r ;
  assign adder_1_in2_EN = CAN_FIRE_RL_generate_random_inputs ;

  // register adder_1_result
  assign adder_1_result_D_IN =
	     { spliced_bits__h474,
	       sum_val__h4712,
	       sum_val__h2134,
	       sum_val__h842 } ;
  assign adder_1_result_EN = CAN_FIRE_RL_adder_1_call_compute ;

  // register b
  assign b_D_IN = rng_b_r ;
  assign b_EN = CAN_FIRE_RL_generate_random_inputs ;

  // register cin
  assign cin_D_IN = rng_cin_r[3] ;
  assign cin_EN = CAN_FIRE_RL_generate_random_inputs ;

  // register count
  assign count_D_IN = count + 8'd1 ;
  assign count_EN = CAN_FIRE_RL_generate_random_inputs ;

  // register cout
  assign cout_D_IN = adder_1_result[32] ;
  assign cout_EN = CAN_FIRE_RL_get_results ;

  // register overflow_flag
  assign overflow_flag_D_IN = x__h14654 & y__h14655 ;
  assign overflow_flag_EN = CAN_FIRE_RL_get_results ;

  // register rng_a_r
  assign rng_a_r_D_IN =
	     WILL_FIRE_RL_generate_random_inputs ?
	       MUX_rng_a_r_write_1__VAL_1 :
	       32'hAFD7CD41 ;
  assign rng_a_r_EN =
	     WILL_FIRE_RL_generate_random_inputs || WILL_FIRE_RL_initialize ;

  // register rng_b_r
  assign rng_b_r_D_IN =
	     WILL_FIRE_RL_generate_random_inputs ?
	       MUX_rng_b_r_write_1__VAL_1 :
	       32'hC9B12E0A ;
  assign rng_b_r_EN =
	     WILL_FIRE_RL_generate_random_inputs || WILL_FIRE_RL_initialize ;

  // register rng_cin_r
  assign rng_cin_r_D_IN =
	     WILL_FIRE_RL_generate_random_inputs ?
	       MUX_rng_cin_r_write_1__VAL_1 :
	       8'hA5 ;
  assign rng_cin_r_EN =
	     WILL_FIRE_RL_generate_random_inputs || WILL_FIRE_RL_initialize ;

  // register state
  always@(MUX_state_write_1__SEL_1 or
	  WILL_FIRE_RL_initialize or
	  WILL_FIRE_RL_generate_random_inputs or WILL_FIRE_RL_get_results)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_state_write_1__SEL_1 || WILL_FIRE_RL_initialize: state_D_IN = 2'd1;
      WILL_FIRE_RL_generate_random_inputs: state_D_IN = 2'd2;
      WILL_FIRE_RL_get_results: state_D_IN = 2'd3;
      default: state_D_IN = 2'bxx /* unspecified value */ ;
    endcase
  end
  assign state_EN =
	     WILL_FIRE_RL_display_results && count_22_ULT_30___d237 ||
	     WILL_FIRE_RL_initialize ||
	     WILL_FIRE_RL_generate_random_inputs ||
	     WILL_FIRE_RL_get_results ;

  // register sum
  assign sum_D_IN = adder_1_result[31:0] ;
  assign sum_EN = CAN_FIRE_RL_get_results ;

  // remaining internal signals
  assign _0_CONCAT_a_38_39_PLUS_0_CONCAT_b_40_41_42_PLUS_ETC___d249 =
	     expected_sum__h14821 == calculated_sum__h14822 ;
  assign adder_1_cin_AND_adder_1_in1_BITS_7_TO_0_XOR_ad_ETC___d113 =
	     x__h8302 |
	     adder_1_in1_BITS_23_TO_16_8_AND_adder_1_in2_BI_ETC___d83[7] ;
  assign adder_1_cin_AND_adder_1_in1_BITS_7_TO_0_XOR_ad_ETC___d77 =
	     x__h4435 |
	     adder_1_in1_BITS_15_TO_8_2_AND_adder_1_in2_BIT_ETC___d47[7] ;
  assign adder_1_in1_BITS_15_TO_8_2_AND_adder_1_in2_BIT_ETC___d47 =
	     adder_1_in1[15:8] & adder_1_in2[15:8] ;
  assign adder_1_in1_BITS_15_TO_8_2_XOR_adder_1_in2_BIT_ETC___d44 =
	     adder_1_in1[15:8] ^ adder_1_in2[15:8] ;
  assign adder_1_in1_BITS_23_TO_16_8_AND_adder_1_in2_BI_ETC___d83 =
	     adder_1_in1[23:16] & adder_1_in2[23:16] ;
  assign adder_1_in1_BITS_23_TO_16_8_XOR_adder_1_in2_BI_ETC___d80 =
	     adder_1_in1[23:16] ^ adder_1_in2[23:16] ;
  assign adder_1_in1_BITS_31_TO_24_14_AND_adder_1_in2_B_ETC___d119 =
	     adder_1_in1[31:24] & adder_1_in2[31:24] ;
  assign adder_1_in1_BITS_7_TO_0_AND_adder_1_in2_BITS_7_ETC___d11 =
	     adder_1_in1[7:0] & adder_1_in2[7:0] ;
  assign adder_1_in1_BITS_7_TO_0_XOR_adder_1_in2_BITS_7_ETC___d8 =
	     adder_1_in1[7:0] ^ adder_1_in2[7:0] ;
  assign calculated_sum__h14822 = { cout, sum } ;
  assign cin__h2129 =
	     x__h9877 |
	     adder_1_in1_BITS_7_TO_0_AND_adder_1_in2_BITS_7_ETC___d11[7] ;
  assign count_22_ULT_30___d237 = count < 8'd30 ;
  assign expected_sum__h14821 = x__h14999 + y__h14840 ;
  assign p__h8574 = adder_1_in1[31:24] ^ adder_1_in2[31:24] ;
  assign spliced_bits__h474 =
	     { x__h13457 |
	       adder_1_in1_BITS_31_TO_24_14_AND_adder_1_in2_B_ETC___d119[7],
	       sum_val__h8578 } ;
  assign sum_val__h2134 =
	     adder_1_in1_BITS_15_TO_8_2_XOR_adder_1_in2_BIT_ETC___d44 ^
	     { x__h4437,
	       x__h4329,
	       x__h4221,
	       x__h4113,
	       x__h4005,
	       x__h3897,
	       x__h3789,
	       cin__h2129 } ;
  assign sum_val__h4712 =
	     adder_1_in1_BITS_23_TO_16_8_XOR_adder_1_in2_BI_ETC___d80 ^
	     { x__h8304,
	       x__h8196,
	       x__h8088,
	       x__h7980,
	       x__h7872,
	       x__h7764,
	       x__h7656,
	       adder_1_cin_AND_adder_1_in1_BITS_7_TO_0_XOR_ad_ETC___d77 } ;
  assign sum_val__h842 =
	     adder_1_in1_BITS_7_TO_0_XOR_adder_1_in2_BITS_7_ETC___d8 ^
	     { x__h9879,
	       x__h9771,
	       x__h9663,
	       x__h9555,
	       x__h9447,
	       x__h9339,
	       x__h9231,
	       adder_1_cin } ;
  assign sum_val__h8578 =
	     p__h8574 ^
	     { x__h13459,
	       x__h13351,
	       x__h13243,
	       x__h13135,
	       x__h13027,
	       x__h12919,
	       x__h12811,
	       adder_1_cin_AND_adder_1_in1_BITS_7_TO_0_XOR_ad_ETC___d113 } ;
  assign x__h12658 =
	     adder_1_cin_AND_adder_1_in1_BITS_7_TO_0_XOR_ad_ETC___d113 &
	     p__h8574[0] ;
  assign x__h12809 = x__h12811 & p__h8574[1] ;
  assign x__h12811 =
	     x__h12658 |
	     adder_1_in1_BITS_31_TO_24_14_AND_adder_1_in2_B_ETC___d119[0] ;
  assign x__h12917 = x__h12919 & p__h8574[2] ;
  assign x__h12919 =
	     x__h12809 |
	     adder_1_in1_BITS_31_TO_24_14_AND_adder_1_in2_B_ETC___d119[1] ;
  assign x__h13025 = x__h13027 & p__h8574[3] ;
  assign x__h13027 =
	     x__h12917 |
	     adder_1_in1_BITS_31_TO_24_14_AND_adder_1_in2_B_ETC___d119[2] ;
  assign x__h13133 = x__h13135 & p__h8574[4] ;
  assign x__h13135 =
	     x__h13025 |
	     adder_1_in1_BITS_31_TO_24_14_AND_adder_1_in2_B_ETC___d119[3] ;
  assign x__h13241 = x__h13243 & p__h8574[5] ;
  assign x__h13243 =
	     x__h13133 |
	     adder_1_in1_BITS_31_TO_24_14_AND_adder_1_in2_B_ETC___d119[4] ;
  assign x__h13349 = x__h13351 & p__h8574[6] ;
  assign x__h13351 =
	     x__h13241 |
	     adder_1_in1_BITS_31_TO_24_14_AND_adder_1_in2_B_ETC___d119[5] ;
  assign x__h13457 = x__h13459 & p__h8574[7] ;
  assign x__h13459 =
	     x__h13349 |
	     adder_1_in1_BITS_31_TO_24_14_AND_adder_1_in2_B_ETC___d119[6] ;
  assign x__h14654 = x__h14656 ^ adder_1_in2[31] ;
  assign x__h14656 = ~adder_1_in1[31] ;
  assign x__h14999 = x__h15001 + y__h15002 ;
  assign x__h15001 = { 1'd0, a } ;
  assign x__h3636 =
	     cin__h2129 &
	     adder_1_in1_BITS_15_TO_8_2_XOR_adder_1_in2_BIT_ETC___d44[0] ;
  assign x__h3787 =
	     x__h3789 &
	     adder_1_in1_BITS_15_TO_8_2_XOR_adder_1_in2_BIT_ETC___d44[1] ;
  assign x__h3789 =
	     x__h3636 |
	     adder_1_in1_BITS_15_TO_8_2_AND_adder_1_in2_BIT_ETC___d47[0] ;
  assign x__h3895 =
	     x__h3897 &
	     adder_1_in1_BITS_15_TO_8_2_XOR_adder_1_in2_BIT_ETC___d44[2] ;
  assign x__h3897 =
	     x__h3787 |
	     adder_1_in1_BITS_15_TO_8_2_AND_adder_1_in2_BIT_ETC___d47[1] ;
  assign x__h4003 =
	     x__h4005 &
	     adder_1_in1_BITS_15_TO_8_2_XOR_adder_1_in2_BIT_ETC___d44[3] ;
  assign x__h4005 =
	     x__h3895 |
	     adder_1_in1_BITS_15_TO_8_2_AND_adder_1_in2_BIT_ETC___d47[2] ;
  assign x__h4111 =
	     x__h4113 &
	     adder_1_in1_BITS_15_TO_8_2_XOR_adder_1_in2_BIT_ETC___d44[4] ;
  assign x__h4113 =
	     x__h4003 |
	     adder_1_in1_BITS_15_TO_8_2_AND_adder_1_in2_BIT_ETC___d47[3] ;
  assign x__h4219 =
	     x__h4221 &
	     adder_1_in1_BITS_15_TO_8_2_XOR_adder_1_in2_BIT_ETC___d44[5] ;
  assign x__h4221 =
	     x__h4111 |
	     adder_1_in1_BITS_15_TO_8_2_AND_adder_1_in2_BIT_ETC___d47[4] ;
  assign x__h4327 =
	     x__h4329 &
	     adder_1_in1_BITS_15_TO_8_2_XOR_adder_1_in2_BIT_ETC___d44[6] ;
  assign x__h4329 =
	     x__h4219 |
	     adder_1_in1_BITS_15_TO_8_2_AND_adder_1_in2_BIT_ETC___d47[5] ;
  assign x__h4435 =
	     x__h4437 &
	     adder_1_in1_BITS_15_TO_8_2_XOR_adder_1_in2_BIT_ETC___d44[7] ;
  assign x__h4437 =
	     x__h4327 |
	     adder_1_in1_BITS_15_TO_8_2_AND_adder_1_in2_BIT_ETC___d47[6] ;
  assign x__h7503 =
	     adder_1_cin_AND_adder_1_in1_BITS_7_TO_0_XOR_ad_ETC___d77 &
	     adder_1_in1_BITS_23_TO_16_8_XOR_adder_1_in2_BI_ETC___d80[0] ;
  assign x__h7654 =
	     x__h7656 &
	     adder_1_in1_BITS_23_TO_16_8_XOR_adder_1_in2_BI_ETC___d80[1] ;
  assign x__h7656 =
	     x__h7503 |
	     adder_1_in1_BITS_23_TO_16_8_AND_adder_1_in2_BI_ETC___d83[0] ;
  assign x__h7762 =
	     x__h7764 &
	     adder_1_in1_BITS_23_TO_16_8_XOR_adder_1_in2_BI_ETC___d80[2] ;
  assign x__h7764 =
	     x__h7654 |
	     adder_1_in1_BITS_23_TO_16_8_AND_adder_1_in2_BI_ETC___d83[1] ;
  assign x__h7870 =
	     x__h7872 &
	     adder_1_in1_BITS_23_TO_16_8_XOR_adder_1_in2_BI_ETC___d80[3] ;
  assign x__h7872 =
	     x__h7762 |
	     adder_1_in1_BITS_23_TO_16_8_AND_adder_1_in2_BI_ETC___d83[2] ;
  assign x__h7978 =
	     x__h7980 &
	     adder_1_in1_BITS_23_TO_16_8_XOR_adder_1_in2_BI_ETC___d80[4] ;
  assign x__h7980 =
	     x__h7870 |
	     adder_1_in1_BITS_23_TO_16_8_AND_adder_1_in2_BI_ETC___d83[3] ;
  assign x__h8086 =
	     x__h8088 &
	     adder_1_in1_BITS_23_TO_16_8_XOR_adder_1_in2_BI_ETC___d80[5] ;
  assign x__h8088 =
	     x__h7978 |
	     adder_1_in1_BITS_23_TO_16_8_AND_adder_1_in2_BI_ETC___d83[4] ;
  assign x__h8194 =
	     x__h8196 &
	     adder_1_in1_BITS_23_TO_16_8_XOR_adder_1_in2_BI_ETC___d80[6] ;
  assign x__h8196 =
	     x__h8086 |
	     adder_1_in1_BITS_23_TO_16_8_AND_adder_1_in2_BI_ETC___d83[5] ;
  assign x__h8302 =
	     x__h8304 &
	     adder_1_in1_BITS_23_TO_16_8_XOR_adder_1_in2_BI_ETC___d80[7] ;
  assign x__h8304 =
	     x__h8194 |
	     adder_1_in1_BITS_23_TO_16_8_AND_adder_1_in2_BI_ETC___d83[6] ;
  assign x__h9078 =
	     adder_1_cin &
	     adder_1_in1_BITS_7_TO_0_XOR_adder_1_in2_BITS_7_ETC___d8[0] ;
  assign x__h9229 =
	     x__h9231 &
	     adder_1_in1_BITS_7_TO_0_XOR_adder_1_in2_BITS_7_ETC___d8[1] ;
  assign x__h9231 =
	     x__h9078 |
	     adder_1_in1_BITS_7_TO_0_AND_adder_1_in2_BITS_7_ETC___d11[0] ;
  assign x__h9337 =
	     x__h9339 &
	     adder_1_in1_BITS_7_TO_0_XOR_adder_1_in2_BITS_7_ETC___d8[2] ;
  assign x__h9339 =
	     x__h9229 |
	     adder_1_in1_BITS_7_TO_0_AND_adder_1_in2_BITS_7_ETC___d11[1] ;
  assign x__h9445 =
	     x__h9447 &
	     adder_1_in1_BITS_7_TO_0_XOR_adder_1_in2_BITS_7_ETC___d8[3] ;
  assign x__h9447 =
	     x__h9337 |
	     adder_1_in1_BITS_7_TO_0_AND_adder_1_in2_BITS_7_ETC___d11[2] ;
  assign x__h9553 =
	     x__h9555 &
	     adder_1_in1_BITS_7_TO_0_XOR_adder_1_in2_BITS_7_ETC___d8[4] ;
  assign x__h9555 =
	     x__h9445 |
	     adder_1_in1_BITS_7_TO_0_AND_adder_1_in2_BITS_7_ETC___d11[3] ;
  assign x__h9661 =
	     x__h9663 &
	     adder_1_in1_BITS_7_TO_0_XOR_adder_1_in2_BITS_7_ETC___d8[5] ;
  assign x__h9663 =
	     x__h9553 |
	     adder_1_in1_BITS_7_TO_0_AND_adder_1_in2_BITS_7_ETC___d11[4] ;
  assign x__h9769 =
	     x__h9771 &
	     adder_1_in1_BITS_7_TO_0_XOR_adder_1_in2_BITS_7_ETC___d8[6] ;
  assign x__h9771 =
	     x__h9661 |
	     adder_1_in1_BITS_7_TO_0_AND_adder_1_in2_BITS_7_ETC___d11[5] ;
  assign x__h9877 =
	     x__h9879 &
	     adder_1_in1_BITS_7_TO_0_XOR_adder_1_in2_BITS_7_ETC___d8[7] ;
  assign x__h9879 =
	     x__h9769 |
	     adder_1_in1_BITS_7_TO_0_AND_adder_1_in2_BITS_7_ETC___d11[6] ;
  assign y__h14655 = adder_1_in2[31] ^ adder_1_result[31] ;
  assign y__h14840 = { 32'b0, cin } ;
  assign y__h15002 = { 1'd0, b } ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        a <= `BSV_ASSIGNMENT_DELAY 32'h70000000;
	adder_1_available <= `BSV_ASSIGNMENT_DELAY 1'd1;
	adder_1_cin <= `BSV_ASSIGNMENT_DELAY 1'd0;
	adder_1_in1 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	adder_1_in2 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	adder_1_result <= `BSV_ASSIGNMENT_DELAY 33'd0;
	b <= `BSV_ASSIGNMENT_DELAY 32'h10000000;
	cin <= `BSV_ASSIGNMENT_DELAY 1'd1;
	count <= `BSV_ASSIGNMENT_DELAY 8'd0;
	cout <= `BSV_ASSIGNMENT_DELAY 1'd0;
	overflow_flag <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rng_a_r <= `BSV_ASSIGNMENT_DELAY 32'd1;
	rng_b_r <= `BSV_ASSIGNMENT_DELAY 32'd1;
	rng_cin_r <= `BSV_ASSIGNMENT_DELAY 8'd1;
	state <= `BSV_ASSIGNMENT_DELAY 2'd0;
	sum <= `BSV_ASSIGNMENT_DELAY 32'd0;
      end
    else
      begin
        if (a_EN) a <= `BSV_ASSIGNMENT_DELAY a_D_IN;
	if (adder_1_available_EN)
	  adder_1_available <= `BSV_ASSIGNMENT_DELAY adder_1_available_D_IN;
	if (adder_1_cin_EN)
	  adder_1_cin <= `BSV_ASSIGNMENT_DELAY adder_1_cin_D_IN;
	if (adder_1_in1_EN)
	  adder_1_in1 <= `BSV_ASSIGNMENT_DELAY adder_1_in1_D_IN;
	if (adder_1_in2_EN)
	  adder_1_in2 <= `BSV_ASSIGNMENT_DELAY adder_1_in2_D_IN;
	if (adder_1_result_EN)
	  adder_1_result <= `BSV_ASSIGNMENT_DELAY adder_1_result_D_IN;
	if (b_EN) b <= `BSV_ASSIGNMENT_DELAY b_D_IN;
	if (cin_EN) cin <= `BSV_ASSIGNMENT_DELAY cin_D_IN;
	if (count_EN) count <= `BSV_ASSIGNMENT_DELAY count_D_IN;
	if (cout_EN) cout <= `BSV_ASSIGNMENT_DELAY cout_D_IN;
	if (overflow_flag_EN)
	  overflow_flag <= `BSV_ASSIGNMENT_DELAY overflow_flag_D_IN;
	if (rng_a_r_EN) rng_a_r <= `BSV_ASSIGNMENT_DELAY rng_a_r_D_IN;
	if (rng_b_r_EN) rng_b_r <= `BSV_ASSIGNMENT_DELAY rng_b_r_D_IN;
	if (rng_cin_r_EN) rng_cin_r <= `BSV_ASSIGNMENT_DELAY rng_cin_r_D_IN;
	if (state_EN) state <= `BSV_ASSIGNMENT_DELAY state_D_IN;
	if (sum_EN) sum <= `BSV_ASSIGNMENT_DELAY sum_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    a = 32'hAAAAAAAA;
    adder_1_available = 1'h0;
    adder_1_cin = 1'h0;
    adder_1_in1 = 32'hAAAAAAAA;
    adder_1_in2 = 32'hAAAAAAAA;
    adder_1_result = 33'h0AAAAAAAA;
    b = 32'hAAAAAAAA;
    cin = 1'h0;
    count = 8'hAA;
    cout = 1'h0;
    overflow_flag = 1'h0;
    rng_a_r = 32'hAAAAAAAA;
    rng_b_r = 32'hAAAAAAAA;
    rng_cin_r = 8'hAA;
    state = 2'h2;
    sum = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_display_results && count_22_ULT_30___d237 &&
	  _0_CONCAT_a_38_39_PLUS_0_CONCAT_b_40_41_42_PLUS_ETC___d249)
	$display("Test Passed");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_display_results && count_22_ULT_30___d237 &&
	  !_0_CONCAT_a_38_39_PLUS_0_CONCAT_b_40_41_42_PLUS_ETC___d249)
	$display("Test Failed: ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_display_results && count_22_ULT_30___d237 &&
	  !_0_CONCAT_a_38_39_PLUS_0_CONCAT_b_40_41_42_PLUS_ETC___d249)
	$display("  %32b\n+ %32b\n+\t\t\t\t %0b\n= \n  %32b", a, b, cin, sum);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_display_results && count_22_ULT_30___d237 &&
	  !_0_CONCAT_a_38_39_PLUS_0_CONCAT_b_40_41_42_PLUS_ETC___d249)
	$display(" %33b", expected_sum__h14821);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_display_results && count_22_ULT_30___d237 &&
	  !_0_CONCAT_a_38_39_PLUS_0_CONCAT_b_40_41_42_PLUS_ETC___d249)
	$display("Cout = %0b", cout);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_display_results && count_22_ULT_30___d237 &&
	  !_0_CONCAT_a_38_39_PLUS_0_CONCAT_b_40_41_42_PLUS_ETC___d249)
	$display("Overflow Flag = %0h\n", overflow_flag);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_display_results && count_22_ULT_30___d237 &&
	  overflow_flag)
	$display("Overflow occured");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_display_results && !count_22_ULT_30___d237)
	$finish(32'd0);
  end
  // synopsys translate_on
endmodule  // mkTestbench

